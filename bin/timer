#!/usr/bin/env bash
# A simple countdown timer written in bash script
# Author: Timothy Lin
# Date: 2011-07-21

# Messages
INTERRUPT_MSG="Count down stopped by user interrupt."
TIMEUP_MSG="Time is up."

# Constants
PAT_WDHMS="^([0-9]+):([0-9]+):([0-9]+):([0-9]+):([0-9]+)$"
PAT_DHMS="^([0-9]+):([0-9]+):([0-9]+):([0-9]+)$"
PAT_HMS="^([0-9]+):([0-9]+):([0-9]+)$"
PAT_MS="^([0-9]+):([0-9]+)$"
PAT_S="^([0-9]+)$"
SELF_NAME="$1"

####################################################################

function show_hint {
	echo "Usage: $(basename $0) [duration | -d date] [-t title] [-m message]"
	echo "Examples:"
	echo "   $(basename $0) 30        # delay 30 seconds"
	echo "   $(basename $0) 1:20:30   # delay 1 hour 20 minutes and 30 seconds"
	echo "   $(basename $0) -d 23:30  # delay until 11:30 PM"
}

####################################################################

# function to get seconds from (weeks,days,hours,minutes,seconds)
# usage: print_seconds week days hours minutes seconds
function print_seconds {
	if [ $# -ne 5 ]; then # check for error
		echo "Error: function print_seconds takes 5 parameters"
		exit 1
	fi
	# weeks, days
	result=`expr $1 \* 604800 + $2 \* 86400`
	# hours, minutes, seconds
	result=`expr $result + $3 \* 3600 + $4 \* 60 + $5`
	echo $result
}

####################################################################

# Parse command line options
sec_rem=0      # remaining seconds
param_prev=""  # previous parameters
for param in $*; do
	
	if [ "${param:0:1}" == "-" ]; then # skip options such as -d
		param_prev=$param
		continue
	fi
	
	case "$param_prev" in
	-d) # assign a date
		NOW=`date +%s`
		UNTIL=`date -d "$param" +%s`
		
		if [ $? -ne 0 ]; then
			exit 1
		fi
		
		sec_rem=`expr $UNTIL - $NOW`
		
		if [ $sec_rem -lt 1 ]; then
			echo "Error: The date $param is already history."
			exit 1
		fi
	
		;;
	-t) # set title
		TITLE="$param"
		;;
	-m) # set message
		MESSAGE="$param"
		;;
	*)  # assign a time
	
		# identify the time format and calculate number of seconds by print_seconds
		if [[ "$param" =~ $PAT_WDHMS ]]; then    # W:D:H:M:S
			sec_rem=`print_seconds ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]} \
				${BASH_REMATCH[4]} ${BASH_REMATCH[5]}`
		elif [[ "$param" =~ $PAT_DHMS ]]; then   # D:H:M:S
			sec_rem=`print_seconds 0 ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]} \
			${BASH_REMATCH[4]}`
		elif [[ "$param" =~ $PAT_HMS ]]; then    # H:M:S
			sec_rem=`print_seconds 0 0 ${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]}`
		elif [[ "$param" =~ $PAT_MS ]]; then     # M:S
			sec_rem=`print_seconds 0 0 0 ${BASH_REMATCH[1]} ${BASH_REMATCH[2]}`			
		elif [[ "$param" =~ $PAT_S ]]; then      # S
			sec_rem=`print_seconds 0 0 0 0 ${BASH_REMATCH[1]}`
		else
			echo "Error: Incorrect time format: $param"
			exit 1
		fi
		
		;;
	esac
	
	param_prev="" # clear the previous parameter

done

####################################################################

# check whether a correct time is assigned
if [ $sec_rem -eq 0 ]; then
	show_hint
	exit 1
fi

# calculate the date when time up
until_date=`expr $(date +%s) + $sec_rem`

####################################################################

# cleanup function
# usage: cleanup_and_exit [message]
function cleanup_and_exit {
	tput cnorm # restore cursor
	stty echo # restore keyboard echo
	clear
	if [ ! -z "$1" ]; then # print message
		echo $1
	fi
	exit 0
}
trap 'cleanup_and_exit "$INTERRUPT_MSG"' INT  # set the cleanup function to be the Control+C handler

####################################################################

clear
tput civis # hide cursor
stty -echo # disable keyboard echo

# count down
while [ 0 -eq 0 ]; do
	
	sec_rem=`expr $until_date - $(date +%s)` # calculate remaining seconds
	if [ $sec_rem -lt 1 ]; then
		break
	fi
	
	interval=$sec_rem
	seconds=`expr $interval % 60`
	interval=`expr $interval - $seconds`
	minutes=`expr $interval % 3600 / 60`
	interval=`expr $interval - $minutes`
	hours=`expr $interval % 86400 / 3600`
	interval=`expr $interval - $hours`
	days=`expr $interval % 604800 / 86400`
	interval=`expr $interval - $hours`
	weeks=`expr $interval / 604800`
	
	if [ ! -z $TITLE ]; then # print the title if it exists
		echo -e "\r$TITLE"
	fi
	echo -e "\r$(date)" # print date
	echo -e "\r----------------------------         "
	echo -e "\rWeeks:    $weeks                     "
	echo -e "\rDays:     $days                      "
	echo -e "\rHours:    $hours                     "
	echo -e "\rMinutes:  $minutes                   "
	echo -e "\rSeconds:  $seconds                   "
	echo -e "\r                                     "
	echo -e "\rPress [q] to stop counting           "
	echo -e "\r                                     "
	if [ ! -z $MESSAGE ]; then # print the message
		echo -e "\r$MESSAGE"
	fi
	
	tput home # move cursor back to (0,0)
	
	# wait for 0.1 second and monitor user input
	read -n 1 -t 0.1 ch
	if [ "$ch" == "q" ]; then
		cleanup_and_exit "$INTERRUPT_MSG"
	fi
	
done

cleanup_and_exit "$TIMEUP_MSG"
